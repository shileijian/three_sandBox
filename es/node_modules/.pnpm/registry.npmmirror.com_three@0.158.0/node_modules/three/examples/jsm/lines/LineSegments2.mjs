import { Vector3 as w, Vector4 as L, Matrix4 as U, Line3 as V, Box3 as q, Sphere as N, Mesh as F, InstancedInterleavedBuffer as G, InterleavedBufferAttribute as I, MathUtils as H } from "../../../build/three.module.mjs";
import { LineSegmentsGeometry as R } from "./LineSegmentsGeometry.mjs";
import { LineMaterial as k } from "./LineMaterial.mjs";
const v = new w(), j = new w(), n = new L(), i = new L(), x = new L(), _ = new w(), T = new U(), r = new V(), C = new w(), B = new q(), z = new N(), y = new L();
let h, S;
function D(u, e, s) {
  return y.set(0, 0, -e, 1).applyMatrix4(u.projectionMatrix), y.multiplyScalar(1 / y.w), y.x = S / s.width, y.y = S / s.height, y.applyMatrix4(u.projectionMatrixInverse), y.multiplyScalar(1 / y.w), Math.abs(Math.max(y.x, y.y));
}
function J(u, e) {
  const s = u.matrixWorld, a = u.geometry, o = a.attributes.instanceStart, c = a.attributes.instanceEnd, l = Math.min(a.instanceCount, o.count);
  for (let t = 0, p = l; t < p; t++) {
    r.start.fromBufferAttribute(o, t), r.end.fromBufferAttribute(c, t), r.applyMatrix4(s);
    const f = new w(), m = new w();
    h.distanceSqToSegment(r.start, r.end, m, f), m.distanceTo(f) < S * 0.5 && e.push({
      point: m,
      pointOnLine: f,
      distance: h.origin.distanceTo(m),
      object: u,
      face: null,
      faceIndex: t,
      uv: null,
      uv1: null
    });
  }
}
function K(u, e, s) {
  const a = e.projectionMatrix, c = u.material.resolution, l = u.matrixWorld, t = u.geometry, p = t.attributes.instanceStart, f = t.attributes.instanceEnd, m = Math.min(t.instanceCount, p.count), d = -e.near;
  h.at(1, x), x.w = 1, x.applyMatrix4(e.matrixWorldInverse), x.applyMatrix4(a), x.multiplyScalar(1 / x.w), x.x *= c.x / 2, x.y *= c.y / 2, x.z = 0, _.copy(x), T.multiplyMatrices(e.matrixWorldInverse, l);
  for (let M = 0, E = m; M < E; M++) {
    if (n.fromBufferAttribute(p, M), i.fromBufferAttribute(f, M), n.w = 1, i.w = 1, n.applyMatrix4(T), i.applyMatrix4(T), n.z > d && i.z > d)
      continue;
    if (n.z > d) {
      const b = n.z - i.z, g = (n.z - d) / b;
      n.lerp(i, g);
    } else if (i.z > d) {
      const b = i.z - n.z, g = (i.z - d) / b;
      i.lerp(n, g);
    }
    n.applyMatrix4(a), i.applyMatrix4(a), n.multiplyScalar(1 / n.w), i.multiplyScalar(1 / i.w), n.x *= c.x / 2, n.y *= c.y / 2, i.x *= c.x / 2, i.y *= c.y / 2, r.start.copy(n), r.start.z = 0, r.end.copy(i), r.end.z = 0;
    const W = r.closestPointToPointParameter(_, !0);
    r.at(W, C);
    const A = H.lerp(n.z, i.z, W), P = A >= -1 && A <= 1, O = _.distanceTo(C) < S * 0.5;
    if (P && O) {
      r.start.fromBufferAttribute(p, M), r.end.fromBufferAttribute(f, M), r.start.applyMatrix4(l), r.end.applyMatrix4(l);
      const b = new w(), g = new w();
      h.distanceSqToSegment(r.start, r.end, g, b), s.push({
        point: g,
        pointOnLine: b,
        distance: h.origin.distanceTo(g),
        object: u,
        face: null,
        faceIndex: M,
        uv: null,
        uv1: null
      });
    }
  }
}
class $ extends F {
  constructor(e = new R(), s = new k({ color: Math.random() * 16777215 })) {
    super(e, s), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const e = this.geometry, s = e.attributes.instanceStart, a = e.attributes.instanceEnd, o = new Float32Array(2 * s.count);
    for (let l = 0, t = 0, p = s.count; l < p; l++, t += 2)
      v.fromBufferAttribute(s, l), j.fromBufferAttribute(a, l), o[t] = t === 0 ? 0 : o[t - 1], o[t + 1] = o[t] + v.distanceTo(j);
    const c = new G(o, 2, 1);
    return e.setAttribute("instanceDistanceStart", new I(c, 1, 0)), e.setAttribute("instanceDistanceEnd", new I(c, 1, 1)), this;
  }
  raycast(e, s) {
    const a = this.material.worldUnits, o = e.camera;
    o === null && !a && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const c = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    h = e.ray;
    const l = this.matrixWorld, t = this.geometry, p = this.material;
    S = p.linewidth + c, t.boundingSphere === null && t.computeBoundingSphere(), z.copy(t.boundingSphere).applyMatrix4(l);
    let f;
    if (a)
      f = S * 0.5;
    else {
      const d = Math.max(o.near, z.distanceToPoint(h.origin));
      f = D(o, d, p.resolution);
    }
    if (z.radius += f, h.intersectsSphere(z) === !1)
      return;
    t.boundingBox === null && t.computeBoundingBox(), B.copy(t.boundingBox).applyMatrix4(l);
    let m;
    if (a)
      m = S * 0.5;
    else {
      const d = Math.max(o.near, B.distanceToPoint(h.origin));
      m = D(o, d, p.resolution);
    }
    B.expandByScalar(m), h.intersectsBox(B) !== !1 && (a ? J(this, s) : K(this, o, s));
  }
}
export {
  $ as LineSegments2
};
